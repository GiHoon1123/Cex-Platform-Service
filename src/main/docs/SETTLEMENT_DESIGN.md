# 거래 정산 도메인 설계 고려사항

## Trade Settlement Domain Design Considerations

> **목적**: 중앙화 거래소(CEX)의 거래 정산 시스템을 구현하며, 정확성, 재현성, 감사 가능성, 확장성을 보장하기 위한 설계 의사결정을 문서화합니다.

---

## 1. 정산 기준 시점 명확화 (Settlement Time Window Definition)

### 문제 상황

- 거래소는 글로벌 서비스이지만, 정산은 특정 비즈니스 타임존 기준으로 수행되어야 함
- UTC와 KST 간 시간대 차이로 인한 정산 범위 오류 가능성
- 일별 정산 시 "하루"의 시작/종료 시점이 모호함

### 해결 방안

- **명시적 타임존 정의**: `Asia/Seoul` (KST) 기준으로 정산 기간 설정
- **정확한 시간 범위 계산**:
  - 시작: `settlementDate 00:00:00 KST`
  - 종료: `settlementDate 23:59:59.999999 KST`
- **일관성 보장**: 모든 정산 쿼리에서 동일한 타임존 사용

### 비즈니스 가치

- 정산 기간의 명확한 정의로 규제 준수 및 내부 감사 용이
- 시간대 차이로 인한 정산 오류 방지
- 재현 가능한 정산 결과 보장

---

## 2. 거래 단위 정산 레코드 (Trade-Level Settlement Records)

### 문제 상황

- 집계된 정산 데이터만 저장 시, 개별 거래 추적 불가능
- 정산 결과 검증 시 원본 거래 데이터 재확인 어려움
- 감사 시 "어떤 거래가 정산에 포함되었는지" 증명 불가

### 해결 방안

- **TradeSettlementItem 엔티티 도입**: 각 거래마다 정산 레코드 생성
- **저장 정보**: 거래 ID, 거래량, 매수자/매도자 수수료, 총 수수료
- **재현성 보장**: 정산일 기준으로 모든 포함된 거래 추적 가능

### 비즈니스 가치

- 정산 결과의 완전한 재현성 확보
- 감사 및 규제 대응 시 상세 증빙 자료 제공
- 정산 오류 발생 시 원인 거래 빠른 식별 가능

---

## 3. 정산 상태 머신 (Settlement State Machine)

### 문제 상황

- 정산 프로세스의 각 단계별 상태 추적 불가
- 정산 실패 시 어느 단계에서 실패했는지 파악 어려움
- 정산 진행 상황 모니터링 및 알림 시스템 구축 어려움

### 해결 방안

- **상태 정의**:
  - `PENDING` → `CALCULATING` → `CALCULATED` → `VALIDATING` → `VALIDATED` / `FAILED` / `ADJUSTED`
- **상태 전이 검증**: 유효하지 않은 상태 전이 방지
- **타임스탬프 기록**: 각 상태 변경 시점 추적

### 비즈니스 가치

- 정산 프로세스의 투명성 확보
- 실패 지점 빠른 식별 및 대응
- 운영 모니터링 및 알림 시스템 구축 기반 마련

---

## 4. 보정 정산 (Adjustment Settlements)

### 문제 상황

- 정산 완료 후 오류 발견 시 원본 데이터 수정의 위험성
- 원본 데이터 변경 시 감사 추적 어려움
- 여러 차례 보정 시 이력 관리 복잡

### 해결 방안

- **불변성 원칙**: 원본 정산 데이터는 수정하지 않음
- **TradeSettlementAdjustment 엔티티**: 보정 내역만 별도 기록
- **보정 타입 구분**: VOLUME, FEE, TRADES 등
- **보정 전/후 값 기록**: JSON 형태로 상세 정보 저장

### 비즈니스 가치

- 원본 데이터 무결성 보장
- 완전한 감사 추적 가능
- 규제 기관 대응 시 투명한 보정 이력 제공

---

## 5. 재시도 전략 (Retry Strategy)

### 문제 상황

- 스케줄러 기반 정산 작업의 일시적 실패 처리
- 네트워크 지연, DB 락 등으로 인한 실패 시 수동 개입 필요
- 정산 실패 시 재실행 프로세스의 복잡성

### 해결 방안

- **Spring Retry 통합**: `@Retryable` 어노테이션 활용
- **지수 백오프**: 초기 2초 대기, 최대 3회 재시도
- **복구 핸들러**: 최종 실패 시 알림 및 로깅

### 비즈니스 가치

- 일시적 오류에 대한 자동 복구
- 운영 부담 감소
- 정산 프로세스의 안정성 향상

---

## 6. 정산 버전 관리 (Settlement Versioning)

### 문제 상황

- 정산 로직 변경 시 과거 정산 결과와의 비교 어려움
- 정책 변경 시 어떤 버전의 로직으로 정산되었는지 추적 불가
- 버그 수정 후 재정산 시 버전 정보 필요

### 해결 방안

- **codeVersion**: 정산 코드/로직 버전 기록
- **policyVersion**: 정산 정책 버전 기록
- **설정 기반 관리**: `application.properties`에서 버전 정보 주입

### 비즈니스 가치

- 정산 로직 변경 이력 추적
- 규제 기관 질의 시 정산 기준 명확히 제시 가능
- 버그 수정 후 재정산 시 버전 정보로 일관성 보장

---

## 7. 감사 로그 강화 (Enhanced Audit Logging)

### 문제 상황

- 정산 데이터 변경 이력 추적 불가
- 누가, 언제, 왜 정산을 변경했는지 기록 부재
- 규제 기관 감사 대응 시 증빙 자료 부족

### 해결 방안

- **TradeSettlementAuditLog 엔티티**: 모든 정산 관련 액션 기록
- **액션 타입**: CREATE, VALIDATE, ADJUST 등
- **상세 정보**: 액션 수행자, IP 주소, User-Agent, 변경 전/후 값
- **에러 핸들링**: 감사 로그 실패가 정산 프로세스를 중단하지 않도록 처리

### 비즈니스 가치

- 완전한 감사 추적 가능
- 규제 준수 및 내부 감사 대응 용이
- 보안 사고 발생 시 원인 분석 기반 마련

---

## 8. 성능 최적화 (Performance Optimization)

### 문제 상황

- 대량 거래 데이터 처리 시 N+1 쿼리 문제 발생
- 개별 INSERT로 인한 성능 저하
- 정산 실행 시간이 수 분 이상 소요

### 해결 방안

- **배치 조회**: 모든 수수료를 한 번의 쿼리로 조회 (`findByCreatedAtBetween`)
- **메모리 그룹핑**: 조회한 데이터를 메모리에서 `tradeId` 기준으로 그룹핑
- **배치 삽입**: `saveAll()`을 사용하여 모든 `TradeSettlementItem`을 한 번에 저장

### 성능 개선 효과

- **쿼리 수 감소**: 거래 수만큼의 쿼리 → 1개의 쿼리 (예: 22,572건 → 1건)
- **INSERT 최적화**: 개별 INSERT → 배치 INSERT
- **실행 시간 단축**: 수 분 → 수 초 (약 100배 이상 개선)

### 비즈니스 가치

- 정산 프로세스의 빠른 완료로 운영 효율성 향상
- 대량 거래 처리 시에도 안정적인 성능 보장
- 확장 가능한 아키텍처 기반 마련

---

## 9. 도메인 분리 전략 (Domain Separation Strategy)

### 문제 상황

- 거래소는 거래 외에도 입출금, 이벤트, 쿠폰 등 다양한 정산 대상 존재
- 모든 정산을 하나의 도메인에서 처리 시 복잡도 증가
- 향후 새로운 정산 유형 추가 시 기존 코드 영향

### 해결 방안

- **하위 도메인 분리**: `settlement.trade`, `settlement.deposit`, `settlement.event` 등
- **도메인별 독립성**: 각 하위 도메인은 자체 엔티티, 서비스, 컨트롤러 보유
- **공통 부분 최소화**: 실제 필요 시에만 공통 컴포넌트 도입
- **명명 규칙**: `TradeSettlement`, `TradeSettlementItem` 등 도메인 접두사 사용

### 비즈니스 가치

- 각 정산 유형의 독립적 개발 및 배포 가능
- 코드 복잡도 관리 및 유지보수성 향상
- 새로운 정산 유형 추가 시 기존 시스템 영향 최소화

---

## 10. 데이터 정확성 보장 (Data Accuracy Guarantees)

### 문제 상황

- BigDecimal 연산 시 정밀도 손실 가능성
- 여러 단계의 집계 과정에서 누적 오차 발생 가능
- 정산 결과 검증 메커니즘 부재

### 해결 방안

- **BigDecimal 사용**: 모든 금액 계산에 `BigDecimal` 사용하여 정밀도 보장
- **집계 검증**: `TradeSettlementItem`의 합계와 `TradeSettlement`의 집계값 일치 확인
- **상태 기반 검증**: `VALIDATING` → `VALIDATED` / `FAILED` 상태 전이를 통한 검증 프로세스

### 비즈니스 가치

- 금융 데이터의 정확성 보장
- 정산 오류 조기 발견 및 대응
- 사용자 및 규제 기관 신뢰 확보

---

## 11. 확장성 고려사항 (Scalability Considerations)

### 현재 구현

- 일별/월별 정산 지원
- 사용자별 정산 지원 (`TradeUserSettlement`)
- 거래쌍별 집계 가능 (향후 확장)

### 향후 확장 가능성

- 실시간 정산 (Real-time Settlement)
- 다중 통화 지원 (Multi-currency Settlement)
- 분산 정산 (Distributed Settlement)
- 정산 결과 API 제공 (Settlement API)

---

## 12. 운영 고려사항 (Operational Considerations)

### 모니터링

- 정산 상태 모니터링: `validationStatus` 기반 알림
- 성능 모니터링: 정산 실행 시간 추적
- 에러 모니터링: 실패한 정산 및 재시도 횟수 추적

### 수동 개입

- 수동 정산 실행 API: `/api/settlement/trade/manual/daily`
- 정산 상세 조회 API: `/api/settlement/trade/details/{date}`
- 정산 검증 API: `/api/settlement/trade/validate`

### 데이터 관리

- 기존 정산 삭제 및 재생성 지원 (테스트 및 재정산 시)
- 정산 데이터 보관 정책 (향후 구현)

---

## 결론

거래 정산 도메인 구현 시 **정확성, 재현성, 감사 가능성, 확장성**을 핵심 가치로 설정하고, 이를 달성하기 위한 구체적인 설계 의사결정을 적용했습니다.

각 고려사항은 단순한 기술적 선택이 아닌, **비즈니스 요구사항과 규제 환경을 고려한 전략적 결정**입니다. 이를 통해 안정적이고 확장 가능한 정산 시스템을 구축할 수 있었습니다.
