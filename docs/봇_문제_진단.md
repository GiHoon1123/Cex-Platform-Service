# 봇 문제 진단 가이드

## 문제 상황

- 봇이 작동하지 않음
- trades 테이블에 데이터가 쌓이지 않음
- Order ID가 45만번대인데 엔진이나 카프카가 이전 데이터를 참고하고 있는지 확인 필요

## 진단 체크리스트

### 1. 봇 주문 생성 확인

```sql
-- 최근 봇 주문 확인 (bot1@bot.com ~ botN@bot.com)
SELECT id, user_id, order_type, order_side, status, created_at
FROM orders
WHERE user_id IN (
    SELECT id FROM users WHERE email LIKE 'bot%@bot.com'
)
ORDER BY id DESC
LIMIT 20;
```

### 2. 엔진 로그 확인

엔진 로그에서 다음을 확인:

- `[Engine Thread] OrderCommand::SubmitOrder 수신` - 주문 수신 여부
- `[Engine Thread] trade_executed 이벤트 발행 시도` - 이벤트 발행 여부
- `[Engine Thread] trade_executed 이벤트 발행 성공` - 이벤트 발행 성공 여부

### 3. 카프카 Consumer 확인

Java 애플리케이션 로그에서 다음을 확인:

- `[Kafka] 체결 이벤트 수신` - 이벤트 수신 여부
- `[Kafka] 체결 이벤트 처리 완료` - 이벤트 처리 완료 여부
- `[Kafka] 주문이 존재하지 않아 체결 처리 스킵` - 주문이 없는 경우

### 4. 카프카 토픽 확인

```bash
# 카프카 토픽 메시지 확인
kafka-console-consumer --bootstrap-server localhost:9092 \
  --topic order-events \
  --from-beginning \
  --max-messages 10
```

### 5. 카프카 Consumer Group Offset 확인

```bash
# Consumer Group의 offset 확인
kafka-consumer-groups --bootstrap-server localhost:9092 \
  --group cex-consumer-group \
  --describe
```

## 가능한 원인 및 해결 방법

### 원인 1: 엔진이 이전 주문 ID를 참고하고 있음

**증상**: 엔진이 주문을 받지만 체결하지 않음
**해결**: 엔진 재시작

### 원인 2: 카프카 Consumer가 이전 offset을 읽고 있음

**증상**: 카프카에 이벤트는 있지만 Consumer가 처리하지 않음
**해결**: Consumer Group 리셋

```bash
# Consumer Group 리셋 (주의: 모든 메시지를 다시 처리)
kafka-consumer-groups --bootstrap-server localhost:9092 \
  --group cex-consumer-group \
  --reset-offsets \
  --to-latest \
  --topic order-events \
  --execute
```

### 원인 3: 주문이 엔진에 제출되지 않음

**증상**: Java에서 주문은 생성되지만 엔진 로그에 나타나지 않음
**해결**:

- 엔진 HTTP 엔드포인트 확인
- 네트워크 연결 확인
- 엔진 로그 확인

### 원인 4: 엔진이 체결하지만 Kafka 이벤트를 발행하지 않음

**증상**: 엔진 로그에 체결은 보이지만 Kafka 이벤트가 없음
**해결**:

- Kafka 연결 확인
- Kafka Producer 설정 확인
- 엔진 로그에서 Kafka 에러 확인

### 원인 5: Kafka 이벤트는 있지만 Consumer가 처리하지 않음

**증상**: Kafka에 이벤트는 있지만 trades 테이블에 저장되지 않음
**해결**:

- Consumer 로그 확인
- 주문이 DB에 존재하는지 확인 (KafkaOrderEventConsumer의 209-214줄 참고)
- 트랜잭션 에러 확인

## 재시작 절차

### 1. 데이터베이스 정리 (선택사항)

```sql
-- 주의: 프로덕션에서는 사용하지 마세요!
-- 테스트 환경에서만 사용

-- trades 테이블 비우기
TRUNCATE TABLE trades CASCADE;

-- orders 테이블 비우기 (선택사항)
-- TRUNCATE TABLE orders CASCADE;
```

### 2. 카프카 토픽 정리 (선택사항)

```bash
# 주의: 프로덕션에서는 사용하지 마세요!
# 테스트 환경에서만 사용

# 토픽 삭제 후 재생성
kafka-topics --bootstrap-server localhost:9092 --delete --topic order-events
kafka-topics --bootstrap-server localhost:9092 --create --topic order-events --partitions 12 --replication-factor 1
```

### 3. Consumer Group 리셋

```bash
# Consumer Group 리셋 (최신부터 읽기)
kafka-consumer-groups --bootstrap-server localhost:9092 \
  --group cex-consumer-group \
  --reset-offsets \
  --to-latest \
  --topic order-events \
  --execute
```

### 4. 엔진 재시작

```bash
# 엔진 종료 후 재시작
# 엔진이 메모리 상태를 초기화하고 새로 시작됨
```

### 5. Java 애플리케이션 재시작

```bash
# Java 애플리케이션 재시작
# 봇이 자동으로 초기화됨 (BotManagerService.initializeBots)
```

## 테스트 절차

### 1. 봇 주문 생성 확인

```bash
# 봇 주문 생성 API 호출 (또는 OrderbookSyncService가 자동으로 생성)
curl -X POST http://localhost:8080/api/bot/orders/1/limit/buy \
  -H "Content-Type: application/json" \
  -d '{
    "baseMint": "SOL",
    "price": 100.0,
    "amount": 1.0
  }'
```

### 2. 엔진 로그 확인

- 주문 수신 확인
- 체결 확인
- Kafka 이벤트 발행 확인

### 3. Kafka 메시지 확인

```bash
kafka-console-consumer --bootstrap-server localhost:9092 \
  --topic order-events \
  --from-beginning \
  --max-messages 5
```

### 4. trades 테이블 확인

```sql
SELECT * FROM trades ORDER BY id DESC LIMIT 10;
```

## 주의사항

1. **프로덕션 환경**: 데이터베이스나 카프카 토픽을 삭제하지 마세요!
2. **Consumer Group 리셋**: 모든 메시지를 다시 처리하므로 주의하세요
3. **엔진 재시작**: 엔진이 메모리 상태를 잃으므로 모든 주문이 초기화됩니다
4. **주문 ID**: Order ID가 45만번대인 것은 정상입니다 (auto increment)

## 추가 확인 사항

### Order ID 불일치 문제

만약 엔진이 이전 Order ID를 참고하고 있다면:

- 엔진이 주문을 받을 때 Order ID를 Java에서 전달받음
- 엔진은 Order ID를 그대로 사용하므로 문제 없어야 함
- 만약 문제가 있다면 엔진이 주문을 제대로 받지 못하는 것

### Kafka Consumer가 주문을 찾지 못하는 문제

KafkaOrderEventConsumer의 209-214줄을 보면:

```java
if (!buyOrderExists || !sellOrderExists) {
    log.warn("[Kafka] 주문이 존재하지 않아 체결 처리 스킵: buyOrderId={} (exists={}), sellOrderId={} (exists={})",
            buyOrderId, buyOrderExists, sellOrderId, sellOrderExists);
    return;
}
```

이 경우:

- 주문이 DB에 없거나
- 트랜잭션 타이밍 문제일 수 있음
- 주문이 삭제되었을 수 있음
